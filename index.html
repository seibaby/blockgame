<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Block Game</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background-color: #eeeeee;
      position: relative;
      overflow: auto;
    }

    /* Infinite grid background */
    .background-grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
      background-size: 25px 25px;
      z-index: -2;
    }

    /* Background pattern cells */
    .background-pattern {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.3;
      filter: blur(1px);
    }

    .bg-cell {
      position: absolute;
      width: 24px;
      height: 24px;
      border: 1px solid rgba(0,0,0,0.2);
      box-sizing: border-box;
    }

    .bg-cell.colored {
      background-color: #4682B4;
    }

    .bg-cell.blocker {
      background-color: #555;
    }

    .bg-cell.shape-green {
      background-color: rgba(0, 128, 0, 0.7);
    }

    .bg-cell.shape-yellow {
      background-color: rgba(255, 215, 0, 0.7);
    }

    /* Game window */
    .game-window {
      position: relative;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      margin: 40px auto;
      padding: 30px;
      max-width: 600px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .game-content {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #controls {
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: center;
    }

    #controls select, #controls input, #controls button {
      padding: 8px 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: white;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    #controls button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }

    #controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    #marker-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background-color: green;
      border-radius: 15px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    .toggle-switch.yellow {
      background-color: gold;
    }

    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 24px;
      height: 24px;
      background-color: white;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .toggle-switch.yellow .toggle-slider {
      transform: translateX(30px);
    }

    #game-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
    }

    .counter {
      text-align: center;
      padding: 12px 16px;
      border: 2px solid #ccc;
      border-radius: 12px;
      background: linear-gradient(135deg, #f9f9f9 0%, #ffffff 100%);
      min-width: 60px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: all 0.2s ease;
    }

    .counter-value {
      font-size: 24px;
      font-weight: bold;
    }

    .green-counter {
      border-color: green;
      background: linear-gradient(135deg, #e8f5e8 0%, #f0fff0 100%);
    }

    .green-counter .counter-value {
      color: green;
    }

    .yellow-counter {
      border-color: gold;
      background: linear-gradient(135deg, #fffacd 0%, #fffff0 100%);
    }

    .yellow-counter .counter-value {
      color: #b8860b;
    }

    .yellow-counter.limit-reached {
      border-color: grey;
      background: linear-gradient(135deg, #f0f0f0 0%, #f8f8f8 100%);
    }

    .yellow-counter.limit-reached .counter-value {
      color: grey;
    }

    #grid {
      display: grid;
      gap: 1px;
    }

    .cell {
      width: 24px;
      height: 24px;
      background-color: white;
      border: 1px solid rgba(0,0,0,0.2);
      box-sizing: border-box;
      position: relative;
      cursor: pointer;
      transition: all 0.1s ease;
    }

    .colored {
      background-color: #4682B4;
    }

    .blocker {
      background-color: #555;
      cursor: pointer;
    }

    .marker-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.5;
      pointer-events: none;
      border-radius: 2px;
    }

    .green .marker-overlay {
      background-color: green;
    }

    .yellow .marker-overlay {
      background-color: gold;
    }

    .invalid-top {
      border-top: 2px solid red !important;
    }

    .invalid-bottom {
      border-bottom: 2px solid red !important;
    }

    .invalid-left {
      border-left: 2px solid red !important;
    }

    .invalid-right {
      border-right: 2px solid red !important;
    }

    .too-small .marker-overlay {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .denied-yellow .marker-overlay {
      background-color: gold;
      animation: fadeOut 0.5s ease-out forwards;
    }

    @keyframes fadeOut {
      0% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    #coloredCountInput, #blockerCountInput {
      width: 60px;
    }

    #seedDisplay {
      margin-top: 15px;
      font-size: 12px;
      color: #666;
      text-align: center;
      padding: 8px 12px;
      background: rgba(0,0,0,0.05);
      border-radius: 6px;
    }

    #result {
      margin-top: 15px;
      font-size: 16px;
      font-weight: 500;
      text-align: center;
      padding: 12px;
      border-radius: 8px;
      min-height: 20px;
    }

    #result:not(:empty) {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .game-window {
        margin: 20px;
        padding: 20px;
      }
      
      #controls {
        flex-direction: column;
        gap: 8px;
      }
      
      #marker-toggle {
        gap: 15px;
      }
    }
  </style>
</head>
<body>
  <!-- Background grid -->
  <div class="background-grid"></div>
  <div class="background-pattern" id="backgroundPattern"></div>

  <!-- Game window -->
  <div class="game-window">
    <div class="game-content">
      <div id="controls">
        <label for="gridSizeSelect">Grid Size:</label>
        <select id="gridSizeSelect" onchange="updateGridSize()">
          <option value="8">8x8</option>
          <option value="12">12x12</option>
          <option value="16" selected>16x16</option>
          <option value="20">20x20</option>
          <option value="24">24x24</option>
        </select>
        <input id="coloredCountInput" type="number" min="1" max="576" />
        <input id="blockerCountInput" type="number" min="0" max="576" />
        <button onclick="createRandomGrid()">New Game</button>
        <button onclick="createTodaysGrid()">Today's Game</button>
        <button onclick="clearMarkers()">Clear All</button>
      </div>
      
      <div id="marker-toggle">
        <div class="counter green-counter">
          <div class="counter-value" id="green-count">0</div>
        </div>
        <div class="toggle-switch" id="color-toggle" onclick="toggleMarkerColor()">
          <div class="toggle-slider"></div>
        </div>
        <div class="counter yellow-counter" id="yellow-counter">
          <div class="counter-value" id="yellow-count">12</div>
        </div>
      </div>
      
      <div id="game-container">
        <div id="grid"></div>
      </div>
      
      <div id="result"></div>
      <div id="seedDisplay"></div>
    </div>
  </div>

  <script>
    let gridSize = 16;
    let totalCells = gridSize * gridSize;
    const grid = document.getElementById('grid');
    const resultDiv = document.getElementById('result');
    const seedDisplay = document.getElementById('seedDisplay');
    const coloredCountInput = document.getElementById('coloredCountInput');
    const blockerCountInput = document.getElementById('blockerCountInput');
    const gridSizeSelect = document.getElementById('gridSizeSelect');
    const greenCountDisplay = document.getElementById('green-count');
    const yellowCountDisplay = document.getElementById('yellow-count');
    const yellowCounterDiv = document.getElementById('yellow-counter');

    let cells = [];
    let markerState = [];
    let coloredCells = new Set();
    let blockerCells = new Set();
    let rng;
    let greenCount = 0;
    let yellowCount = 0;
    const maxYellowMarkers = 12;
    let currentMarkerColor = 'green';
    const colorToggle = document.getElementById('color-toggle');

    // Simple seeded RNG using a Linear Congruential Generator
    class SeededRNG {
      constructor(seed) {
        this.seed = this.hashString(seed);
      }

      hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }

      next() {
        this.seed = (this.seed * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.seed / Math.pow(2, 32);
      }
    }

    // Create background pattern
    function createBackgroundPattern() {
      const backgroundPattern = document.getElementById('backgroundPattern');
      const bgRng = new SeededRNG('background-pattern');
      
      const cellSize = 25;
      const cols = Math.ceil(window.innerWidth / cellSize) + 2;
      const rows = Math.ceil(window.innerHeight / cellSize) + 2;
      
      backgroundPattern.innerHTML = '';
      
      // Place random colored and blocker cells
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (bgRng.next() < 0.15) { // 15% chance for special cells
            const cell = document.createElement('div');
            cell.className = 'bg-cell';
            cell.style.left = (x * cellSize) + 'px';
            cell.style.top = (y * cellSize) + 'px';
            
            if (bgRng.next() < 0.7) {
              cell.classList.add('colored');
            } else {
              cell.classList.add('blocker');
            }
            
            backgroundPattern.appendChild(cell);
          }
        }
      }
      
      // Add some example shapes
      const shapes = [
        // Green L-shape (6 cells)
        { cells: [[10, 5], [11, 5], [12, 5], [10, 6], [10, 7], [10, 8]], color: 'green' },
        // Yellow square (4 cells)
        { cells: [[25, 8], [26, 8], [25, 9], [26, 9]], color: 'yellow' },
        // Green line (5 cells)
        { cells: [[40, 12], [41, 12], [42, 12], [43, 12], [44, 12]], color: 'green' },
        // Green T-shape (7 cells)
        { cells: [[15, 20], [16, 20], [17, 20], [18, 20], [19, 20], [17, 21], [17, 22]], color: 'green' },
        // Green zigzag (8 cells)
        { cells: [[35, 3], [36, 3], [36, 4], [37, 4], [37, 5], [38, 5], [38, 6], [39, 6]], color: 'green' },
      ];
      
      shapes.forEach(shape => {
        shape.cells.forEach(([x, y]) => {
          const cell = document.createElement('div');
          cell.className = `bg-cell shape-${shape.color}`;
          cell.style.left = (x * cellSize) + 'px';
          cell.style.top = (y * cellSize) + 'px';
          backgroundPattern.appendChild(cell);
        });
      });
    }

    function getTodaysSeed() {
      const today = new Date();
      return today.toISOString().split('T')[0];
    }

    function index(x, y) {
      return y * gridSize + x;
    }

    function xy(i) {
      return [i % gridSize, Math.floor(i / gridSize)];
    }

    function neighbors(i) {
      const [x, y] = xy(i);
      const result = [];
      if (x > 0) result.push(index(x - 1, y));
      if (x < gridSize - 1) result.push(index(x + 1, y));
      if (y > 0) result.push(index(x, y - 1));
      if (y < gridSize - 1) result.push(index(x, y + 1));
      return result;
    }

    function defaultColoredCount(size) {
      const totalCells = size * size;
      return Math.floor(3 * totalCells / 16);
    }

    function defaultBlockerCount(size) {
      const totalCells = size * size;
      return Math.floor(totalCells / 16);
    }

    function toggleMarkerColor() {
      currentMarkerColor = currentMarkerColor === 'green' ? 'yellow' : 'green';
      if (currentMarkerColor === 'yellow') {
        colorToggle.classList.add('yellow');
      } else {
        colorToggle.classList.remove('yellow');
      }
    }

    function updateCounters() {
      greenCount = markerState.filter(state => state === 'green').length;
      yellowCount = markerState.filter(state => state === 'yellow').length;
      
      greenCountDisplay.textContent = greenCount;
      yellowCountDisplay.textContent = maxYellowMarkers - yellowCount;
      
      if (yellowCount >= maxYellowMarkers) {
        yellowCounterDiv.classList.add('limit-reached');
      } else {
        yellowCounterDiv.classList.remove('limit-reached');
      }
    }

    function updateGridSize() {
      gridSize = parseInt(gridSizeSelect.value, 10);
      totalCells = gridSize * gridSize;
      coloredCountInput.value = defaultColoredCount(gridSize);
      blockerCountInput.value = defaultBlockerCount(gridSize);
      createTodaysGrid();
    }

    function getConnectedComponentSize(cellSet, startCell) {
      const visited = new Set();
      const queue = [startCell];
      visited.add(startCell);
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        for (let neighbor of neighbors(current)) {
          if (!visited.has(neighbor) && cellSet.has(neighbor)) {
            visited.add(neighbor);
            queue.push(neighbor);
          }
        }
      }
      
      return visited.size;
    }

    function wouldCreateLargeComponent(cellSet, newCell, maxSize = 12) {
      const tempCells = new Set([...cellSet, newCell]);
      return getConnectedComponentSize(tempCells, newCell) > maxSize;
    }

    function placeRandomCells(count, excludeSet) {
      const result = new Set();
      const maxAttempts = count * 50;
      let attempts = 0;
      
      while (result.size < count && attempts < maxAttempts) {
        const candidate = Math.floor(rng.next() * totalCells);
        attempts++;
        
        if (excludeSet.has(candidate) || result.has(candidate)) {
          continue;
        }
        
        if (!wouldCreateLargeComponent(result, candidate, 12)) {
          result.add(candidate);
        }
      }
      
      return result;
    }

    function wouldCreateEnclosedSpace(blockerSet, newBlocker) {
      const tempBlockers = new Set([...blockerSet, newBlocker]);
      
      const nonBlockerCells = [];
      for (let i = 0; i < totalCells; i++) {
        if (!tempBlockers.has(i)) {
          nonBlockerCells.push(i);
        }
      }
      
      const visited = new Set();
      let componentCount = 0;
      
      for (let cell of nonBlockerCells) {
        if (!visited.has(cell)) {
          const queue = [cell];
          visited.add(cell);
          let canReachBorder = false;
          
          while (queue.length > 0) {
            const current = queue.shift();
            const [x, y] = xy(current);
            
            if (x === 0 || x === gridSize - 1 || y === 0 || y === gridSize - 1) {
              canReachBorder = true;
            }
            
            for (let neighbor of neighbors(current)) {
              if (!visited.has(neighbor) && !tempBlockers.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
              }
            }
          }
          
          componentCount++;
          
          if (!canReachBorder) {
            return true;
          }
        }
      }
      
      return false;
    }

    function placeBlockersWithoutEnclosing(count, excludeSet) {
      const result = new Set();
      const maxAttempts = count * 50;
      let attempts = 0;
      
      while (result.size < count && attempts < maxAttempts) {
        const candidate = Math.floor(rng.next() * totalCells);
        attempts++;
        
        if (excludeSet.has(candidate) || result.has(candidate)) {
          continue;
        }
        
        if (!wouldCreateEnclosedSpace(result, candidate)) {
          result.add(candidate);
        }
      }
      
      return result;
    }

    function createGrid(customSeed = null) {
      let seed;
      if (customSeed) {
        seed = customSeed;
        seedDisplay.innerText = `Seed: ${seed}`;
      } else {
        seed = getTodaysSeed() + '-' + gridSize;
        seedDisplay.innerText = `Daily seed: ${seed}`;
      }
      
      rng = new SeededRNG(seed);

      grid.style.gridTemplateColumns = `repeat(${gridSize}, 24px)`;
      grid.innerHTML = '';
      cells = [];
      markerState = Array(totalCells).fill(null);
      coloredCells = placeRandomCells(parseInt(coloredCountInput.value, 10), new Set());
      blockerCells = placeBlockersWithoutEnclosing(parseInt(blockerCountInput.value, 10), coloredCells);

      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        if (coloredCells.has(i)) cell.classList.add('colored');
        if (blockerCells.has(i)) cell.classList.add('blocker');

        const overlay = document.createElement('div');
        overlay.classList.add('marker-overlay');
        cell.appendChild(overlay);

        cell.addEventListener('click', e => {
          e.preventDefault();
          if (blockerCells.has(i)) return;
          
          if (currentMarkerColor === 'yellow') {
            if (markerState[i] !== 'yellow' && yellowCount >= maxYellowMarkers) {
              cell.classList.add('denied-yellow');
              setTimeout(() => {
                cell.classList.remove('denied-yellow');
              }, 500);
              return;
            }
            
            if (markerState[i] === 'yellow') {
              markerState[i] = null;
              cell.classList.remove('yellow');
            } else {
              markerState[i] = 'yellow';
              cell.classList.remove('green');
              cell.classList.add('yellow');
            }
          } else {
            if (markerState[i] === 'green') {
              markerState[i] = null;
              cell.classList.remove('green');
            } else {
              markerState[i] = 'green';
              cell.classList.remove('yellow');
              cell.classList.add('green');
            }
          }
          
          updateCounters();
          updateGameState();
        });

        grid.appendChild(cell);
        cells.push(cell);
      }
      updateCounters();
      updateGameState();
    }

    function createRandomGrid() {
      const randomSeed = Date.now() + '-' + Math.floor(Math.random() * 10000) + '-' + gridSize;
      createGrid(randomSeed);
    }

    function createTodaysGrid() {
      createGrid();
    }

    function clearMarkers() {
      for (let i = 0; i < totalCells; i++) {
        markerState[i] = null;
        cells[i].classList.remove('green', 'yellow', 'invalid-top', 'invalid-bottom', 'invalid-left', 'invalid-right', 'too-small');
      }
      resultDiv.innerText = '';
      updateCounters();
      updateGameState();
    }

    function updateGameState() {
      for (let cell of cells) {
        cell.classList.remove('invalid-top', 'invalid-bottom', 'invalid-left', 'invalid-right', 'too-small');
      }

      let visited = new Array(totalCells).fill(false);
      let clumps = [];

      for (let i = 0; i < totalCells; i++) {
        if (!visited[i] && (markerState[i] === 'green' || markerState[i] === 'yellow')) {
          let queue = [i], clump = [], color = markerState[i];
          visited[i] = true;

          while (queue.length > 0) {
            let curr = queue.pop();
            clump.push(curr);

            for (let n of neighbors(curr)) {
              if (!visited[n] && markerState[n] === color) {
                visited[n] = true;
                queue.push(n);
              }
            }
          }

          clumps.push({ color, cells: clump });
        }
      }

      let valid = true;
      for (let { cells: group } of clumps) {
        if (group.length < 4) {
          for (let i of group) {
            cells[i].classList.add('too-small');
          }
          valid = false;
        } else if (group.length > 12) {
          for (let i of group) {
            const [x, y] = xy(i);
            for (let [dx, dy, cls] of [[0, -1, 'invalid-top'], [0, 1, 'invalid-bottom'], [-1, 0, 'invalid-left'], [1, 0, 'invalid-right']]) {
              let nx = x + dx, ny = y + dy;
              if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) {
                cells[i].classList.add(cls);
              } else {
                let ni = index(nx, ny);
                if (!group.includes(ni)) cells[i].classList.add(cls);
              }
            }
          }
          valid = false;
        }
      }

      let blueCovered = [...coloredCells].every(i => markerState[i] === 'green' || markerState[i] === 'yellow');
      let blockerFree = [...blockerCells].every(i => markerState[i] === null);

      if (valid && blueCovered && blockerFree) {
        resultDiv.innerText = `ðŸŽ‰ Puzzle complete! Clumps used: ${clumps.length}, Markers used: ${markerState.filter(v => v).length}`;
      } else {
        resultDiv.innerText = '';
      }
    }

    // Initialize
    coloredCountInput.value = defaultColoredCount(gridSize);
    blockerCountInput.value = defaultBlockerCount(gridSize);
    
    // Create background pattern on load and resize
    createBackgroundPattern();
    window.addEventListener('resize', createBackgroundPattern);
    
    createGrid();
  </script>
</body>
</html>
